# 稳稳地 TCP

**TCP 是面向连接、可靠传输、面向字节流的传输控制协议(Transmission Control Protocol)。**

## TCP 协议段格式

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190703151455929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY3ODUwNw==,size_16,color_FFFFFF,t_70)

- 源/目的端口号：表示数据是从哪里来，到哪里去。
- 32 位序号/ 32 位确认号：为保证 TCP 可靠传输的一种机制。
- 4 位首部长度：表示该 TCP 首部有多少个字节。一行是四个字节；若选项为空，则 TCP 首部长度为 20 字节，若选项不为空且为最大(选项最大可有 40 字节)，则 TCP 首部长度为 60 字节。(TCP 最大首部长度就是 60 字节)
- 保留 6 位：该字段主要为了以后扩展时使用，其长度为 4 为。一般设置为 0 ，但即使收到的包在该字段不为 0，此包也不会被丢弃。
- 6 位标志位：
  - URG：紧急指针是否有效。
  - ACK：确认号是否有效。
  - PSH：提示接收端应用程序立刻从 TCP 缓冲区把数据读走。
  - RST：对方要求重新建立连接；我们把携带 RST 标识的称为 **复位报文段**。
  - SYN：请求建立连接；我们把携带 SYN 标识的称为 **同步报文段**。
  - FIN：通知对方，本端要关闭了；我们把携带 FIN 标识的称为 **结束报文段**。
- 16 位窗口大小：该字段长为 16 位。用于通知从相同的 TCP 首部的确认应答号所指位置开始能够接收的数据大小。TCP 不允许发送超过此处所示大小的数据。不过，如果窗口为 0，则表示可以发送窗口探测，以了解最新的窗口大小。但这个数据必须是 1 个字节。
- 16 位校验和：跟 UDP 一样使用 CRC 校验，但是这里的校验不光包含 TCP 首部，还包含 TCP 数据部分。
- 16 位紧急指针：标识哪部分数据时紧急数据。
- 40 字节头部选项：选项字段用于提高 TCP 的传输性能。

---



## 可靠传输

### 连接管理

### 三次握手：检查网络连通状态，协商一些关键性的数据

正常情况下，TCP 要经过三次握手建立连接。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190703153841796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY3ODUwNw==,size_16,color_FFFFFF,t_70)

> 图片来自 《图解TCP_IP》

如上图，当客户端需要和服务器建立连接的过程中：

1. 客户端首先给服务器发送一个 SYN 请求建立连接，发送后 自己处于 SYN_SENT 状态。
2. 服务器收到 SYN 请求后，给客户端返回一个 ACK 确认应答，并且发送一个 SYN 请求。发送后自己处于一个 SYN_RECV 状态。
3. 客户端收到后，给服务器返回一个 ACK 确认应答。并处于 ESTABLISHED 状态。
4. 服务器收到客户端的确认应答后，自己也处于 ESTABLISHED 状态，且这个时候客户端就可以和服务器进行通信了。

#### 握手为什么是三次而不是两次？

那么这里就会引出来一个问题，为什么不是两次握手，也就是说，服务端给客户端返回一个 ACK 之后就可以让两个设备保持连接为什么还要客户端返回一个 ACK 呢？

三次握手，双方确认对方是否具备数据收发能力，两次不安全，四次没必要。

客户端第一次发送 SYN 的时候，有可能因为网络的原因阻塞，而当服务器收到 SYN 请求的时候，有可能客户端已经退出了，如果这个时候只有两次握手，服务器给客户端发送 ACK 后就默认客户端具有接收的能力，后续就会出现错误。所以需要客户端给服务器一个确认。

#### 三次握手失败怎么办？(一般是第三次握手失败)

服务器等不到客户端的 ACK 确认应答，就会给客户端发送一个 RST 报文，要求客户端重新建立连接，并销毁刚才服务器创建的 socket。

### 四次挥手

在上图的下半部分也充分表示了四次挥手的过程：

1. 客户端要断开连接，向服务器发送一个 FIN 包，并且自己处于 FIN_WAIT1 状态。
2. 服务器收到客户端发来的 FIN 包，服务器会向客户端返回一个 ACK 确认应答，并处于一个 CLOSE_WAIT 状态。
3. 客户端收到服务器发来的 ACK 就会处于 FIN_WAIT2 状态。
4. 服务器也会向客户端发送一个 FIN 包，并处于 LAST_ACK 状态。
5. 客户端收到服务器发来的 FIN 包，会向服务器发送 ACK 并处于 TIME_WAIT 状态。过一会才会处于 CLOSED 状态。
6. 服务器收到客户端发来的 ACK 自己就处于了 CLOSED 状态。

####  为什么最后客户端向服务器发送 ACK 之后处于 TIME_WAIT 状态还要等一会才能变成 CLOSED 状态？

TIME_WAIT 的作用：因为有可能最后一次客户端给服务端的 ACK可能会失败，所以当失败的时候，服务端没有接收到客户端
发送的 ACK，所以服务器会重传 FIN，然后等待的客户端会重传  ACK。

如果没有TIME_WAIT，如果其他客户端重新起来，碰巧占用相同端口那么这个客户端一启动向服务端发送 SYN 请求，但是服务端在等待 ACK，所以服务端会把 SYN 丢到掉。或者客户端起来直接收到服务端发送的 FIN 包，这个时候客户端就会产生疑惑。

所以假如没有TIME_WAIT，客户端直接关闭，但是又重启了相同地址的客户端有可能因为四次挥手最后一次 ACK 丢失导致服务端重传FIN包，对后续连接造成影响新客户端发送 SYN 到服务端，服务端认为状态有误，回复重置连接的报文-RST报文因此主动关闭方发送最后一个ACK后不能直接关闭，需要等待一段时间--2个 MSL 时间
MSL：报文最大生存周期

等待两个MSL时间是为了能够处理对端重传的FIN包进行ACK回复；并且等待两个MSL时间是为了让所有网络中延迟的报文都消失在网络中，不会对后续连接造成影响。

#### 服务端出现大量 TIME_WAIT 的原因？该如何解决

服务端出现大量 TIME_WAIT 的原因是有大量的客户端主动断开。

解决方法：

1. 减小 TIME_WAIT 的等待时间。
2. 配置地址重用。就是说当一个客户端处于一个 TIME_WAIT 状态，可以新启动一个和这个等待的客户端地址一样的客户端与服务器新建立连接传输数据。(setsockopt接口)

#### 为什么挥手要四次而握手只要三次？

因为有可能在用户在发送 FIN 包之前给服务器发送了很多数据，当客户端发送完 FIN 包之后服务端直接回复 ACK，然后在服务端发送FIN包之前，先将所有数据处理完，之后再给客户端发送 FIN  包，然后再等客户端给服务端发送 ACK。

但是根据我自己的抓包实验，发现服务端将 ACK 和 FIN 包一起发送给客户端。上网查阅资料得知，服务器接收到客户端的FIN包后并不会立即返回 ACK。而是才用延迟应答的机制，先处理完数据之后，当服务器要给客户端发送 FIN 包的时候才用捎带应答的机制把之前的 ACK 返回给客户端。这样的做法大大的减小了网络阻塞的概率。

#### 服务器中出现大量的 CLOSE_WAIT 状态是什么原因？

忘记调用 close() 了呗。

---



### 确认应答机制

![在这里插入图片描述](https://img-blog.csdnimg.cn/201907041520595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY3ODUwNw==,size_16,color_FFFFFF,t_70)

主机 A 给主机 B 发送数据的时候，会有 OS 产生一个序号，当主机 B 收到 A 发来的数据时，会对序号加上主机 A 发送来的数据的字节数，赋值给确认序号，返回给主机 A。这个时候主机 A 就知道主机 B 已经收到了它刚才发过去的数据。以此类推。这就是确认应答机制。

---



### 超时重传机制

当主机 A 给主机 B 发数据时，不论是发送的数据丢失，还是主机 B 给主机 A 返回的确认应答丢失，只要主机 A 在一定时间内没有收到主机 B 给自己的确认应答，主机 A  就认为数据丢失，并且重新把刚才的数据给主机 B 发送一份。

---



### 校验和

这里的校验和 和 UDP 的校验和一样。都是采用 CRC 校验和。保证数据发送前和发送后一致。如果接受方收到的数据算出的校验和 和 发送的数据的校验和不一致，接受方就认为该数据有一些丢包或损坏，就会丢弃该数据。

---



## 提高性能，优化策略

那么这样看来，虽然 TCP 保证了数据的可靠传输，但是发送方发送一个数据，接受方接收一个数据，这样一来一回，会让网络的负载增大，严重会造成网络阻塞，那么有没有什么办法优化优化呢？

那么肯定有，这里 TCP 的优化主要思想就一个 **尽量多的发送数据，减少 ACK 的发送**。

### 滑动窗口机制

一次性可以发送大量的数据（受限于协议字段中的窗口大小），然后等待回复。

**滑动窗口中的流量控制**
通信双方通过协议字段中的窗口大小来协商接下来应该发送的最大数据长度。窗口大小不大于当前接收缓冲区中空闲空间大小，避免因为发送数据过多，导致缓冲区放满，而丢弃数据导致重传
滑动窗口中数据的连续发送，尽力避免因为ack丢失导致重传
确认回复中的ack确认序号能够表示这个序号之前的数据都已经接收到了。若前面的数据没有接收到，反而接收到了后面的数据，则不会对后面的数据进行ack确认。
**滑动窗口中的快速重传机制**
当接收端接收数据的时候，若第一条数据没到，但是接收到了第二条数据，认为第一天数据有可能丢失，立即向发送端连续多次发送重传请求；发送端连续发送三次重传请求，则对这条数据进行重传。

---

### 拥塞控制机制

滑动窗口的大小并不单纯由滑动窗口的流量控制来决定，还有有一个拥塞控制，在流量控制的窗口大小和拥塞控制的窗口大小取一个较小值，作为滑动窗口的窗口大小。

#### 慢启动，快增长

首先将窗口大小设置位 1，然后窗口大小为一个指数的形式增长。增长到某一指定阈值的时候，窗口大小就会变成线性增长。

首次启动的时候，这个阈值是一个操作系统大概取的一个值。

当传输的时候网络阻塞了（阻塞就是发生丢包了），这个窗口又会立刻回到 1，并且阈值设置为刚才发生阻塞时的窗口大小的一半。然后又会重新进行慢启动快增长机制。

---

### 延迟应答

当接收方收到数据之后，并不会立刻进行确认应答，而是等一段时间再进行确认应答。

比如

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705111956728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY3ODUwNw==,size_16,color_FFFFFF,t_70)

当接收方的接收缓冲区只有 100K 的时候，这个时候发送方给接收方发来一个 20K 的数据。如果接收方立刻回复 ACK，那么窗口大小就剩下 80K 了。如果接收方等一会，等它自己将这个数据取走了，然后再回复 ACK，那么窗口大小就可以设置为 100K 。

**延迟应答的策略：**

- 数量限制：每隔 N 个包就应答一次。
- 时间限制：超过最大延迟时间就应答一次。

---

### 捎带应答

捎带应答就是，当接收方接收到数据之后，并不直接回复 ACK。而是等待数据处理完毕之后，将数据和 ACK 一起发送给发送方

---

## TCP粘包问题

TCP的粘包有可能在发送端产生，也有可能在接收端产生。
发送端：发送的时候先把数据放到缓冲区，放了好多数据之后才发送，接收端就接收了所有的数据，会让接收端处理起来很麻烦。
接收端：有可能发送端发过来没来得及recv，第二条数据就发过来了，然后接收的时候一起就接收了。

### 解决方法：

tcp产生粘包就是内核并没有对send要发送的数据没有明确的边界区分，需要用户在应用层解决TCP粘包问题。

1. 就像 HTTP 协议一样用分隔符的方法来区分。
2. 指定长度，就像 UDP 协议一样，可以指定发送的数据报的长度，所以 UDP 协议就不会存在粘包问题。

---

## TCP 异常情况

进程终止、关机、重启，进程都会释放文件描述符，仍然可以发送 FIN，和正常关闭没区别。

但是机器断电/网线断开都不会正常断开连接。接收端会认为连接还在，一旦接收端有写入操作，接收端就会发现连接不在了，就会向发送端发送 RST 重置连接请求。

### 保活机制

有的时候发送端异常退出，接收端还一直不给发送端发送数据怎么办，接收端有一个保活机制，会定期询问对方还在不在，如果连续发送几个询问都得不到回答，接收端就认为对端已经不再了，就会释放连接。